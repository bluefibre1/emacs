




#+STARTUP: overview
#+TITLE: Marc's Emacs
#+CREATOR: Marc Demers
#+LANGUAGE: en

[[./dashLogo.png]]

This is my personal Emacs configuration file. It was greatly inspired by Dawid Eckert's config available here: https://github.com/daedreth/UncleDavesEmacs.  

* Installation

Clone my repository in your home folder.

=git clone https://github.com/bluefibre1/emacs/ ~/.emacs.d=

Keep in mind that you should remove your own ~/.emacs and your ~/.emacs.d
prior to cloning this configuration. The next time you launch Emacs (and I recommend launching emacs in the tty for the first time) it's going to download a good amount of packages and configure them for you, you might see warnings and errors being displayed as well, those are safe to ignore as long as you relaunch emacs and see none.
* Operating Systems
** Mac
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
    (set-default-font "Monaco 15")
    (global-set-key [home] 'move-beginning-of-line)
    (global-set-key [end] 'move-end-of-line)
    (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    (setq exec-path (append exec-path '("/usr/local/bin"))))
#+END_SRC
** Linux
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'gnu/linux)
      t)
#+END_SRC
** Windows
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'windows-nt)
      (set-default-font "Consolas 15"))
#+END_SRC

* Emacs Configuration
** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration
   
Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

* Interface
** Theme
The most important part of every configuration.
#+BEGIN_SRC emacs-lisp
  (use-package hemisu-theme
    :ensure t
    :init
      (load-theme 'hemisu-dark t))
#+END_SRC
** Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to =dashboard=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
  (when window-system
        (use-package pretty-mode
        :ensure t
        :config
        (global-pretty-mode t)))
#+END_SRC

** Dashboard
 This is your new startup screen, together with projectile it works in unison and
 provides you with a quick look into your latest projects and files.
 Change the welcome message to whatever string you want and
 change the numbers to suit your liking, I find 5 to be enough.
 #+BEGIN_SRC emacs-lisp
   (use-package dashboard
     :ensure t
     :config
       (dashboard-setup-startup-hook)
       (setq dashboard-startup-banner "~/.emacs.d/dashLogo.png")
       (setq dashboard-items '((recents  . 5)
                               (projects . 5)))
       (setq dashboard-banner-logo-title ""))
 #+END_SRC
** Modeline
 The modeline is the heart of emacs, it offers information at all times, it's persistent
 and verbose enough to gain a full understanding of modes and states you are in.

 Due to the fact that we attempt to use emacs as a desktop environment replacement,
 and external bar showing the time, the battery percentage and more system info would be great to have.
 I have however abandoned polybar in favor of a heavily modified modeline, this offers me more space
 on the screen and better integration.

 One modeline-related setting that is missing and is instead placed at the bottom is =diminish=.
*** Spaceline!
 I may not use spacemacs, since I do not like evil-mode and find spacemacs incredibly bloated and slow,
 however it would be stupid not to acknowledge the best parts about it, the theme and their modified powerline setup.

 This enables spaceline, it looks better and works very well with my theme of choice.
 #+BEGIN_SRC emacs-lisp
   (use-package spaceline
     :ensure t
     :config
     (require 'spaceline-config)
       (setq spaceline-buffer-encoding-abbrev-p nil)
       (setq spaceline-line-column-p nil)
       (setq spaceline-line-p nil)
       (setq powerline-default-separator (quote arrow))
       (spaceline-spacemacs-theme))
 #+END_SRC

*** No separator!
 #+BEGIN_SRC emacs-lisp
   (setq powerline-default-separator nil)
 #+END_SRC

*** Cursor position
 Show the current line and column for your cursor.
 We are not going to have =relative-linum-mode= in every major mode, so this is useful.
 #+BEGIN_SRC emacs-lisp
   (setq line-number-mode t)
   (setq column-number-mode t)
 #+END_SRC

*** Diminish
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'org-indent-mode)
    (diminish 'which-key-mode))
#+END_SRC

** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
    (use-package beacon
      :ensure t
      :diminish beacon-mode
      :config
	(beacon-mode 1))
#+END_SRC
** Ask Quit Confirmation
#+BEGIN_SRC emacs-lisp
  (defun ask-before-closing ()
    "Ask whether or not to close, and then close if y was pressed."
    (interactive)
    (if (y-or-n-p (format "Are you sure you want to exit Emacs? "))
        (if (< emacs-major-version 22)
            (save-buffers-kill-terminal)
          (save-buffers-kill-emacs))
      (message "Canceled exit")))
(when window-system
  (global-set-key (kbd "C-x C-c") 'ask-before-closing))
#+END_SRC
** Cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
* General
** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
** Backups And Auto Saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC

** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Minimize
Always hitting this key by mistake, disabling it
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-z"))
#+END_SRC
** Pasting
For my disabled fingers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f4>") 'yank)
#+END_SRC
** Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC
** Moving
*** Prerequisite for others packages
 #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :ensure t)
 #+END_SRC

*** Scrolling and why does the screen move
 I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
 #+BEGIN_SRC emacs-lisp
   (setq scroll-conservatively 100)
 #+END_SRC
*** Switch-window
This magnificent package takes care of this issue.
It's unnoticeable if you have <3 panes open, but with 3 or more, upon pressing =C-x o=
you will notice how your buffers turn a solid color and each buffer is asigned a letter
(the list below shows the letters, you can modify them to suit your liking), upon pressing
a letter asigned to a window, your will be taken to said window, easy to remember, quick to use
and most importantly, it annihilates a big issue I had with emacs. An alternative is =ace-window=,
however by default it also changes the behaviour of =C-x o= even if only 2 windows are open,
this is bad, it also works less well with =exwm= for some reason.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC
*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

*** Buffers
 Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
 Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.

 Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
 #+BEGIN_SRC emacs-lisp
   (defun kill-current-buffer ()
     "Kills the current buffer."
     (interactive)
     (kill-buffer (current-buffer)))
   (global-set-key (kbd "C-x k") 'kill-current-buffer)
 #+END_SRC
** Electric Pairs
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC
** Parenthesis
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC* Searhing
** Default Search
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn't hurt to search for entire words or mode, swiper makes sure this is more efficient.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . 'swiper))
#+END_SRC

** Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :diminish helm-mode
    :bind
    ("C-x C-r" . helm-recentf)
    ("C-x C-f" . 'helm-find-files)
    ("C-x C-b" . 'helm-buffers-list)
    ("C-x b" . 'helm-buffers-list)
    ("M-x" . 'helm-M-x)
    :config
    (defun daedreth/helm-hide-minibuffer ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face
                       (let ((bg-color (face-background 'default nil)))
                         `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))
    (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
    (setq helm-autoresize-max-height 0
          helm-autoresize-min-height 40
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-split-window-in-side-p nil
          helm-move-to-line-cycle-in-source nil
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8 
          helm-echo-input-in-header-line t
          helm-boring-buffer-regexp-list '("\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*Minibuf"))
    :init
    (helm-mode 1))

  (require 'helm-config)    
  (helm-autoresize-mode 1)
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
#+END_SRC
** Goto Word In Screen
Many times have I pondered how I can move around buffers even quicker.
I'm glad to say, that avy is precisely what I needed, and it's precisely what you need as well.
In short, as you invoke one of avy's functions, you will be prompted for a character
that you'd like to jump to in the /visible portion of the current buffer/.
Afterwards you will notice how all instances of said character have additional letter on top of them.
Pressing those letters, that are next to your desired character will move your cursor over there.
Admittedly, this sounds overly complicated and complex, but in reality takes a split second
and improves your life tremendously.

I like =M-s= for it, same as =C-s= is for moving by searching string, now =M-s= is moving by searching characters.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
      ("M-s" . avy-goto-char))
#+END_SRC
** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
** Snippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :config
        (use-package yasnippet-snippets
          :ensure t)
        (yas-reload-all))
#+END_SRC

** Spell Check
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands global-flycheck-mode
    :diminish flycheck-mode)
#+END_SRC

** Completion
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish company-mode
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 2))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC* Text Manipulation
Here I shall collect self-made functions that make editing text easier.
** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!
#+BEGIN_SRC emacs-lisp
  (use-package mark-multiple
    :ensure t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC

** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/kill-inner-word ()
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC

** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
        (point-at-bol)
        (point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'daedreth/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC
** Which-key
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
      (which-key-mode))
#+END_SRC
** Recents
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure t
  :defer t
  :config
  (progn
    (recentf-mode 1)
    (setq recentf-max-menu-items 200)
    (setq recentf-max-saved-items 200)
    (add-to-list 'recentf-exclude "\\.el\\'")))
    #+END_SR
* Project
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode 1)
    :config
    (progn
      (setq projectile-completion-system 'helm)
      (setq projectile-globally-ignored-files (append '("*.o" "*.so" "GTAGS" "GRTAGS" "GPATH" "*.log" "*.txt" "*.exe" "*.svg" "*.zip" "*.pyc" "*.jar" "*.sdf")))
      (setq grep-find-ignored-files projectile-globally-ignored-files)
      (setq projectile-globally-ignored-directories (append '("bin" "CMakeFiles" ".git")))
      (setq grep-find-ignored-directories projectile-globally-ignored-directories)
      (setq projectile-switch-project-action 'helm-projectile)
      (setq projectile-indexing-method 'alien)
      (setq projectile-enable-caching t)
      (setq compilation-scroll-output 'first-error)))
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f7>") 'projectile-compile-project)
#+END_SRC
* Programming
** Line numbers
Every now and then all of us feel the urge to be productive and write some code.
In the event that this happens, the following bit of configuration makes sure that 
we have access to relative line numbering in programming-related modes.
I highly recommend not enabling =linum-relative-mode= globally, as it messed up 
something like =ansi-term= for instance.
#+BEGIN_SRC emacs-lisp
    (use-package linum-relative
      :ensure t
      :diminish linum-relative-mode
      :config
	(setq linum-relative-current-symbol "")
	(add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC
** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

** Languages
*** Bash
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'flycheck-mode)

#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
*** Bat
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package bat-mode
    :ensure t
    :defer t
    :mode ("\\.\\(bat\\)$" . bat-mode)
    :interpreter ("bat" . bat-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'bat-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'bat-mode-hook 'flycheck-mode)
#+END_SRC
*** C/C++
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))
#+END_SRC

**** company
Requires libclang to be installed.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC
*** CSharp
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t
    :defer t
    :mode ("\\.\\(cs\\)$" . csharp-mode)
    :interpreter ("csharp" . csharp-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'csharp-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'csharp-mode-hook 'flycheck-mode)
#+END_SRC
*** Emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC
*** Javascript
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :defer t
    :mode ("\\.\\(js\\)$" . json-mode)
    :interpreter ("node" . json-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'js2-mode-hook 'flycheck-mode)
#+END_SRC
*** Json
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :defer t
    :mode ("\\.\\(json\\)$" . json-mode)
    :interpreter ("json" . json-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'json-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'json-mode-hook 'flycheck-mode)
#+END_SRC
*** LaTeX
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package tex-site
    :ensure auctex
    :mode ("\\.\\(tex\\)$" . latex-mode)
    :config
    (progn
      (setq-default TeX-auto-save t)
      (setq-default TeX-parse-self t)
      (setq-default TeX-save-query nil)
      (setq-default TeX-master nil)
      (add-hook 'LaTeX-mode-hook
                (lambda ()
                  (rainbow-delimiters-mode)
                  (company-mode)
                  (smartparens-mode)
                  (flyspell-mode)
                  (setq TeX-PDF-mode t)
                  (setq TeX-source-correlate-method 'synctex)
                  (setq TeX-source-correlate-start-server t)))))
#+END_SRC
*** Lua
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'flycheck-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'company-mode)

  (defun custom-lua-repl-bindings ()
    (local-set-key (kbd "C-c C-s") 'lua-show-process-buffer)
    (local-set-key (kbd "C-c C-h") 'lua-hide-process-buffer))

  (defun lua-mode-company-init ()
    (setq-local company-backends '((company-lua
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-lua
    :ensure t
    :config
      (require 'company)
      (setq lua-indent-level 4)
      (setq lua-indent-string-contents t)
      (add-hook 'lua-mode-hook 'custom-lua-repl-bindings)
      (add-hook 'lua-mode-hook 'lua-mode-company-init))
#+END_SRC
*** Markdown
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :defer t
    :mode ("\\.\\(md\\)$" . markdown-mode)
    :interpreter ("markdown" . markdown-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 'flycheck-mode)
#+END_SRC
*** Python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC
**** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
      (require 'company)
      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC
*** Yaml
**** Mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer t
    :mode ("\\.\\(yml\\)$" . yaml-mode)
    :interpreter ("yaml" . yaml-mode))
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'yaml-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'yaml-mode-hook 'flycheck-mode)
#+END_SRC



** Source Control
*** Git
Countless are the times where I opened ansi-term to use =git= on something.
These times are also something that I'd prefer stay in the past, since =magit= is
great. It's easy and intuitive to use, shows its options at a keypress and much more.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC
*** Perforce
#+BEGIN_SRC emacs-lisp
(use-package p4
 :ensure t
 :defer t
 :bind-keymap (("M-p" . p4-prefix-map)))
#+END_SRC

* Org
** Common
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (diminish 'org-indent-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC
** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
	    '(lambda ()
	       (visual-line-mode 1)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

